---
title: "Are Presidents Predictable: An Analysis of SONA Addresses"
---
# Abstract

This paper critically examines various State of the Nation Address (SONA) speeches of South African presidents from 1994 to 2023. The aim is to categorise sentences from SONA speeches into their presidential speaker. Utilising Natural Language Processing (NLP) techniques, three feature extraction tools: Bag of Words (BoW), Term Frequency-Inverse Document Frequency (TF-IDF), and Word Tokenization are considered. Three predictive models, namely Gradient Boosted Trees, Feed Forward Neural Networks, and Support Vector Machines, are then applied and assessed regarding their classification ability across the feature extraction methods. Preliminary data exploration revealed significant dataset imbalances in presidential representation. The findings underscore the superior performance of traditional feature extraction methods in TF-IDF and less so BoW over Word Embeddings. Support Vector Machines, especially when coupled with TF-IDF, demonstrate remarkable accuracy at around 61%. Despite the promising results, challenges such as dataset imbalances and the limitations of Word Embeddings highlight potential areas for future research. The study concludes by emphasizing the potential of integrating insights from multiple disciplines and refining methodologies for a comprehensive understanding of political speeches.

# Introduction

This paper critically analyzes the State of the Nation Address (SONA) speeches delivered by various South African presidents from 1994 to 2023. The primary objective is to categorize each president based on single sentences extracted from their respective SONA speeches. The study unfolds as follows: Initially, a concise literature review is presented, with emphasis on the domain of Natural Language Processing (NLP), particularly focusing on classification tasks within NLP. This review lays the groundwork for the methodologies and approaches applied in later sections of the paper. Subsequent sections offer an in-depth exploration and meticulous cleaning of the data utilized in the study. The exploration phase scrutinizes the dataset's balance and analyzes the vocabulary used, both overall and by each specific president. These preliminary steps are crucial for ensuring the integrity and reliability of the study's findings. The paper then transitions to a detailed exposition of the methodologies employed in the study. The methods section elucidates the three feature extraction tools deployed: Bag of Words (BoW), Term Frequency-Inverse Document Frequency (TF-IDF), and Word Tokenization. Additionally, it describes the three predictive models applied, namely Gradient Boosted Trees, Feed Forward Neural Networks, and Support Vector Machines. Each tool and model is presented with a rationale for its inclusion and an explanation of its contribution to the study's objectives.

Following the methods section, the paper presents and succinctly discusses the study's results. This section provides an initial interpretation of the findings, preparing the ground for the more in-depth analysis that follows. In the penultimate section, a comprehensive discussion of the results is provided. This discussion delves into the insights gleaned from the findings, offering detailed interpretations and drawing connections with the literature reviewed earlier. This section aims not only to shed light on the study's findings but also to locate these within the broader academic discourse on the subject. Finally, the paper concludes with a reflective overview of the study as a whole. This concluding section evaluates the study's successes and limitations, reflects on its contributions to the field, and suggests avenues for future research and exploration. Through this reflective lens, the paper not only summarizes its findings but also invites further scholarly engagement with the questions and challenges raised during the study.

# Literature Review

NLP has become an in-vogue machine learning practice recently, the availability of rich sources of textual data through platforms like Twitter, coupled with the explosion of transformer-based models usage has led to the topic of text analysis to become a highly researched and applied method(Khurana et al., 2022). The first phase of NLP relies on feature extraction, methods traditional methods like BoW proposed and TF-IDF, while high in dimensionality, provide a sparse matrix representation of otherwise complex text data(Dogra et al., 2022). Other more recent methods like word embeddings, have been shown to be extremely useful, picking up semantics and nuance previously undiscovered. Models used for sentence classifications include traditional machine learning methods like Naive Bayes classifiers and SVMS(Dogra et al., 2022) as well as more standard classification methods like random forests and more recently gradient-boosted trees and advanced neural network architectures. 

Newer transformer learning-based transfer learning models like BERT proposed by (Devlin et al., 2019) have garnered massive attention due to their significant performance in NLP tasks ranging from sentiment analysis to classification tasks in NLP. Though these methods are computationally very expensive and are rooted in a large corpus that they are trained on(Kotei & Thirunavukarasu, 2023).


# Methods

The methods applied fall into four main categories that also follow the workflow of the project. More specifically, data pre-processing, feature extraction, modelling and model evaluation.

## Data Pre-Processing
In the data preprocessing phase before feature extraction, initial data loading was accomplished from text files, with each file containing SONA speeches from different South African presidents from 1994 to 2023. Files were filtered to ensure they were valid, and the president’s names were extracted and cleaned for later use. The speeches within each file were tokenized into sentences using the NLTK library, and any unnecessary newline characters within these sentences were removed. Each sentence was then associated with the relevant president, resulting in a structured data frame containing each sentence alongside its corresponding president’s name. Following this, the data underwent exploratory data analysis (EDA) where sentences associated with specific presidents were filtered out, and sentence lengths were calculated and visualized. The sentences were further cleaned by removing stop words (common words that do not contribute to the meaning of a sentence) and then grouped by president. Subsequently, the cleaned sentences were used for generating word clouds for visual inspection. Furthermore, the most common words across all presidents were calculated and the average words per sentence were computed and plotted for each president.


## Feature Extraction


### Bag of Words (BoW)

The Bag of Words (BoW) method represents text data as a matrix of token (typically words) occurrences within a given document. Each row of the matrix corresponds to a document, while each column represents a unique token in the dataset. The matrix cell contains the count of occurrences of the token in the document. In mathematical terms, for a set of  $n$ documents $D$ and a set of $m$ unique tokens $T$, the BoW matrix $M$ is a $n \times m$ matrix where $M_{ij}$ is the frequency of token $j$ in document $i$(Akuma et al., 2022). For the dataset in question, each sentence from the president’s speeches is treated as a document. The BoW model tokenizes each sentence into words, creating a matrix that reflects the frequency count of each word within each sentence, yielding a sparse matrix representation of the word distribution in each president's speech.

### Term Frequency-Inverse Document Frequency (TF-IDF)

The Term Frequency-Inverse Document Frequency (TF-IDF) technique assigns a weight to each term in a document reflecting its importance in the document relative to the entire corpus. The TF-IDF value of a term $t$ in a document $d$ within a corpus $D$ is computed as $\text{TF-IDF}(t, d) = \text{TF}(t, d) \times \text{IDF}(t, D)$, where $\text{TF}(t, d)$ is the frequency of term $t$ in document $d$ divided by the total number of terms in $d$, and $\text{IDF}(t, D)$ is the logarithm of the total number of documents in $D$ divided by the number of documents containing term $t$(Akuma et al., 2022). In the context of the dataset, TF-IDF is calculated for each term in every sentence, resulting in a vector of TF-IDF values for each sentence, thereby emphasizing terms that are distinctive to specific speeches or presidents.

### Word Embeddings
Sentences from the presidential speeches dataset are tokenized into words. These tokens are then fed into the Word2Vec model, which learns vector representations for each word by predicting the context in which a word appears, effectively capturing the semantic relationships between words(Řehůřek, 2022). Upon training Word2Vec with the tokenized sentences, each word is represented as a high-dimensional vector. To form a representative vector for a complete sentence, the word vectors within each sentence are averaged. This results in a single vector per sentence, encapsulating the semantic essence of the sentence based on its constituent words.

These sentence-level vectors serve as the dataset's numerical features, providing a semantically rich representation of the sentences for subsequent machine-learning applications in the project. Each vector not only represents its sentence but also mirrors the inherent semantic structure and relationships within the text, offering a meaningful feature set for analysis( Řehůřek, 2022). By employing these methods, the raw textual data from the speeches is transformed into a numerical format suitable for training machine learning models.

## Modelling 

Note that for each of the following predictive models, each of the three feature extraction methods detailed above are applied.

### Gradient Boosted Trees

Gradient Boosting is a general technique where models are built sequentially, with each new model being trained to correct the mistakes of the combined ensemble of existing models. This process is iteratively repeated, progressively improving the model’s accuracy until further improvements are negligible(Brownlee, 2021).

Gradient Boosted Trees (GBTs) inherently leverage an ensemble methodology, combining the predictive power of multiple weak learners, in decision trees, to create a more accurate and robust model. The algorithm incrementally builds an ensemble of trees where each subsequent tree compensates for the errors of the aggregate set of preceding trees(Friedman, 2001). Through this iterative refinement, the algorithm not only enhances its precision but also avoids overfitting, providing a reliable generalization to unseen data.

In our deployment of GBTs, using Yandex's CatBoost, careful parameter tuning was essential for optimized performance. We engaged 500 boosting iterations, a 0.05 learning rate, and a tree depth of 10. The boosting iterations define the number of trees in the model, with each iteration adding a new tree that corrects the errors of the ensemble. The learning rate, alternatively known as shrinkage, moderates the influence of each tree, preventing any single tree from dominating the ensemble prediction. The tree depth, meanwhile, influences the model's complexity, with deeper trees allowing for the capture of more complex patterns in the data but at the risk of overfitting. These parameters were selected after running a grid search over hyperparameters choosing the hyperamters which minimised validation error computed using 5-fold cross-validation.

### Support Vector Machines

Support Vector Machines (SVMs) is a supervised learning algorithm used for classification tasks. SVMs operate by constructing hyperplanes in a multidimensional space that separates cases of different class labels(Shmilovici, 2005). The SVM algorithm is implemented in practice using a kernel. The kernel trick helps in fitting the maximum-margin hyperplane in the transformed feature space. The hyperplane is selected to segregate classes in the best possible way.

In this project, SVM classifiers were employed with various parameter configurations, and their performance was evaluated based on the processed data obtained through the feature extraction methods previously mentioned. A grid search approach was utilized to explore a range of parameter values and identify the optimal configuration for each data representation method. The grid search was performed over a range of values for the `C` parameter, different kernel types, and the gamma coefficient for the Radial Basis Function (RBF) kernel. Specifically, the `C` parameter was explored over the values `[0.1, 1, 10]`. The `C` parameter represents the regularization term, controlling the trade-off between having a smooth decision boundary and classifying the training points correctly(Sklearn, 2023).

The kernel parameter, with values `['linear', 'rbf']`, specifies the type of hyperplane used to separate the data. The linear kernel is often used when the data is linearly separable, meaning it can be separated by a single line(Sklearn, 2023). The RBF kernel is used for non-linear data, transforming it into a higher-dimensional space where it becomes linearly separable. The gamma parameter, with values `['scale', 'auto']`, defines how far the influence of a single training example reaches, with low values meaning 'far' and high values meaning 'close'(Sklearn, 2023).

For the SVM model trained on data represented using Bag of Words, the grid search optimal parameters were `C=0.1`,  a `linear` kernel and `gamma='scale'`. When using TF-IDF, the optimal parameters were `C=10`, a `RBF` kernel with `gamma='scale'`. Finally, for Word Embeddings, a `C` value of `10`, a `linear` kernel, and `gamma='scale'`.

### Neural Networks

The Neural Network (NN) model deployed in this project is a multilayer perceptron (MLP), which is a type of feedforward neural network(Goodfellow et al., 2016). The input data was converted from a sparse to a dense matrix format. The architecture employed was the same across all feature extraction methods as varying the model architecture did not prove to yield any significant difference in model performance across the feature extraction methods. 

The architecture of the NN consists of an input layer, a hidden layer, and an output layer. The input layer has 505 neurons, with a Rectified Linear Unit (ReLU) as the activation function. ReLU was chosen due to its effectiveness in mitigating the vanishing gradient problem(Glorot et al., 2011). For the weight initialization for the input layer, the He normal initializer was used. This initializer assists in breaking symmetry and facilitating the learning process(), and ensures a less-naive starting point for the weights(He et al., 2015). Additionally, to avoid overfitting, L2 regularization with a coefficient of $1 \times 10^{-8}$ was applied.

The hidden layer also uses a ReLU activation function and the He normal initializer,  with 220 neurons. L2 regularization using $1 \times 10^{-7}$ was incorporated.
The softmax activation function is used in the final layer to output a probability distribution over the multiple classes.

During the training phase, a stratified 5-fold cross-validation strategy was employed. For each fold, the data was split into training and validation subsets, with the model being trained for 20 epochs. The sparse categorical cross-entropy was selected as the loss function, being appropriate for multi-class classification problems. The Adam optimizer was utilized for its adaptive learning rate capabilities. Following examination of the plot of training versus validation accuracy over epochs, the optimal number of epochs for training was set, and the final model was trained and subsequently evaluated on the unseen test data. 

## Model Evaluation Metrics

The evaluation of the models' performance employed a suite of metrics to ensure a comprehensive assessment. The primary metrics used are accuracy and F1-score. Accuracy is defined as the ratio of correctly predicted observations to the total observations:

$\text{Accuracy} = \frac{\text{Number of Correct Predictions}}{\text{Total Number of Predictions Made}}$

While accuracy is a straightforward and informative metric, it is not sufficient where the classes are imbalanced. Hence, additional evaluative metrics were incorporated into the assessment framework. Stratified k-fold cross-validation (with $k = 5$ ) was used during the training phase of Neural Networks (NNs).

Subsequently, confusion matrices were generated for the models. A confusion matrix is a table used to describe the performance of a classification algorithm. Each row of the matrix represents the instances of the actual class, while each column represents the instances of the predicted class. The entries on the main diagonal of the confusion matrix correspond to correct predictions, whereas other entries reflect the mistakes made by the classifier. Through the confusion matrix, the F1-score was computed to provide a detailed understanding of the model’s performance, F1 score is composed of two other metrics in precision and recall. Precision (the ratio of true positive predictions to the sum of true positive and false positive predictions), and recall (the ratio of true positive predictions to the sum of true positive and false negative predictions), are both utilized to form the F1-score (the harmonic mean of precision and recall). 

For the Gradient Boosted Trees model, the loss function was an essential aspect of the evaluation. The loss function is a measure used to estimate the discrepancy between the predicted values and actual values. During the training process, the algorithm optimizes the model parameters to minimize this loss function, thereby improving the model’s predictive performance. Monitoring the change in the value of the loss function during the training process provides insights into the convergence and stability of the model, helping in understanding whether the model is learning effectively from the training data. For each training epoch, the loss was computed and analyzed to ensure the model was converging to a solution that minimized prediction errors.

```{python}
#| echo: false
#| error: false
#| output: false
#| include: false
pip install nltk requests matplotlib seaborn sklearn scikit-learn wordcloud catboost tensorflow gensim
```

```{python}
#| echo: false
#| error: false
#| output: false
pip install wordcloud
```

```{python}
#| include: false
pip install gensim
```

```{python}
#| include: false
pip install tensorflow==2.14.0
```


```{python}
#| include: false
pip install keras==2.14.0
```

```{python}
#| include: false
pip install joblib
```

```{python}
#| include: false
pip install pickle
```

```{python}
#| include: false
pip install plotly
```

```{python}
#| include: false
pip install nbformat==4.2.0
```

```{python}
#| include: false
pip install --upgrade nbformat
```
```{python}
#| include: false
pip install ipython
```
```{python}
#| include: false
# General imports
import pickle
import nbformat
from joblib import dump, load
import os
import pandas as pd
import re
import numpy as np

# NLTK imports
import nltk
from nltk.tokenize import sent_tokenize
nltk.download('punkt')

# Visualization imports
import matplotlib.pyplot as plt
import seaborn as sns
from wordcloud import WordCloud, STOPWORDS

# Preprocessing imports
from sklearn.feature_extraction.text import CountVectorizer, ENGLISH_STOP_WORDS, TfidfVectorizer
from sklearn.preprocessing import LabelEncoder

# Model selection imports
from sklearn.model_selection import train_test_split, GridSearchCV

# Machine learning model imports
from sklearn.svm import SVC
from catboost import CatBoostClassifier
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.regularizers import l2
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
from catboost import Pool, cv, CatBoostClassifier

# Word embedding imports
from gensim.models import Word2Vec

# Metrics import
from sklearn.metrics import classification_report, accuracy_score
```


```{python}
#| echo: false
folder_path = 'speeches' 
files = os.listdir(folder_path)
files = sorted([file for file in files if os.path.isfile(os.path.join(folder_path, file)) and file.endswith('.txt')])

president_names = []


pattern = r'_(.+?)\.txt'  

for file in files:
    match = re.search(pattern, file)
    if match:
        president_name = match.group(1)
        # Remove the "_2" suffix from the president names here
        cleaned_president_name = president_name.replace('_2', '')
        president_names.append(cleaned_president_name)
    else:
        print(f"Warning: No match found in filename: {file}")
        president_names.append('Unknown')  # Placeholder for missing names

# Check the lengths of files and president_names lists
if len(files) != len(president_names):
    print(f"Warning: Number of files ({len(files)}) does not match number of president names ({len(president_names)})")

# Initialize dataframe with appropriate column names
df = pd.DataFrame(columns=['Presidents', 'Sentences'])

# Iterate over all files and extract sentences
for file_index in range(len(files)):
    file_path = os.path.join(folder_path, files[file_index])
    with open(file_path, 'r', encoding='utf-8') as file:
        lines = file.readlines()[2:]  # Adjust if your files have a different structure

    text = ' '.join(lines)
    sentences = sent_tokenize(text)
    cleaned_sentences = [sentence.replace('\n', '') for sentence in sentences]

    current_president = president_names[file_index]
    dftemp = pd.DataFrame({'Presidents': [current_president] * len(cleaned_sentences), 'Sentences': cleaned_sentences})
    df = pd.concat([df, dftemp], axis=0, ignore_index=True)

df.reset_index(drop=True, inplace=True)

# Save the DataFrame to a CSV file
#df.to_csv('finalSentence.csv', index=False)
```


```{python}
#| echo: false
data = pd.read_csv("finalSentence.csv")
```

# Results

## Data Exploration Results
Prior to investigating the models, a preliminary data exploration was conducted to understand the data better. We begin first by plotting the number of sentences per president to understand the balance of the dataset shown in Figure 1. The bar plot displays the distribution of sentence counts associated with six South African presidents: Zuma, Mbeki, Ramaphosa, Mandela, Motlanthe, and de Klerk. Zuma leads with 2629 sentences, suggesting he is the most frequently mentioned in the dataset. Mbeki follows closely with 2397 sentences, and Ramaphosa is third with 2279 sentences. Mandela is associated with 1671 sentences, significantly fewer than the top three. Motlanthe and de Klerk are the least mentioned, with only 264 and 97 sentences respectively. Hence given the imbalance of the dataset including Motlanthe and de Klerk, we choose to drop these two presidents from our dataset moving forward.

```{python}
#| fig-cap: "Figure 1: Number of Sentences per President"
#| echo: false
#| warning: false
# Set the style of the visualization
sns.set(style="whitegrid")

# Group the data by president and count the number of sentences for each
sentence_counts = data['Presidents'].value_counts()

plt.figure(figsize=(10, 6))
sns.barplot(x=sentence_counts.index, y=sentence_counts.values, palette="viridis")

plt.xlabel('Presidents')
plt.ylabel('Number of Sentences')
plt.xticks(rotation=45)
plt.show()


```

```{python}
#| include: false
data = data[data['Presidents'] != ' Motlanthe']
data = data[data['Presidents'] != 'deKlerk']
```


 
 Figure 2 illustrates the average sentence lengths for four South African presidents: Mbeki, Mandela, Ramaphosa, and Zuma. Mbeki's sentences are the longest, averaging around $30.99$ words, indicating more complex or detailed discourse related to him. Mandela’s average is slightly shorter at $25.87$ words per sentence, followed by Ramaphosa with $22.83$ words. Zuma has the shortest sentences, averaging $19.43$ words, suggesting more concise communication associated with him. These differences might reflect variations in communication styles or the nature of the texts related to each president in the dataset.


```{python}
#| fig-cap: "Figure 2: Average Sentence Length per President"
#| warning: false
#| echo: false
# Calculate the length in words of each sentence
data['Sentence_Length'] = data['Sentences'].apply(lambda x: len(x.split()))

average_length = data.groupby('Presidents')['Sentence_Length'].mean().sort_values(ascending=False)

palette = sns.color_palette("viridis", n_colors=len(sentence_counts))

color_mapping = {president: palette[i] for i, president in enumerate(sentence_counts.index)}

bar_colors = [color_mapping[president] for president in average_length.index]

plt.figure(figsize=(10, 6))
sns.barplot(x=average_length.index, y=average_length.values, palette=bar_colors)

# Add labels and title
plt.xlabel('Presidents')
plt.ylabel('Average Sentence Length (in words)')
plt.xticks(rotation=45)
plt.show()

```

In figure 3, the term "government" stands out as the most frequently used, highlighting the focus on governance in the presidential speeches. References to "South," "Africa," and economic terms like "development" and "economic" suggest an emphasis on regional affairs and economic growth. Words such as "people," "public," and "national" underscore the significance of civic engagement and national identity. 

```{python}
#| fig-cap: "Figure 3: Top 20 most common words used across all presidents"
#| echo: false
#| warning: false

# Use CountVectorizer to count word frequencies
vectorizer = CountVectorizer(stop_words='english', max_features=20)
X = vectorizer.fit_transform(data['Sentences'])
word_freq_df = pd.DataFrame({'word': vectorizer.get_feature_names_out(),
                             'frequency': np.asarray(X.sum(axis=0)).ravel()})

word_freq_df = word_freq_df.sort_values('frequency', ascending=False)

# Plotting the bar plot for the top 20 words
plt.figure(figsize=(12, 8))
sns.barplot(x='frequency', y='word', data=word_freq_df)
plt.title('Top 20 most common words used across all presidents')
plt.xlabel('Frequency')
plt.ylabel('Word')
plt.show()

```



From Figure 4 we can examine the word clouds of South African presidents Mandela, Ramaphosa, Mbeki, and Zuma, noting the distinct thematic priorities that emerge. Mandela's discourse leaned towards nation-building, emphasizing "government," "people," and "national." Ramaphosa highlighted economic terms like "investment" and "growth," while maintaining a strong national identity. Mbeki's governance approach is reflected in terms such as "process" and "system," with "South African" underscoring unity. Zuma's tenure was marked by infrastructure and economic themes, seen in "development" and "economy." Across all leaders, a shared commitment to governance and the South African populace is evident. 
```{python}
#| fig-cap: "Figure 4: Word Cloud per President"
#| echo: false
# function to remove stop words from a sentence
def remove_stopwords(sentence):
    words = sentence.split()
    cleaned_words = [word for word in words if word.lower() not in STOPWORDS]
    return ' '.join(cleaned_words)

data['Cleaned_Sentences'] = data['Sentences'].apply(remove_stopwords)

grouped = data.groupby('Presidents')['Cleaned_Sentences'].apply(' '.join).reset_index()

wordclouds = {}

#  word cloud for each president
for index, row in grouped.iterrows():
    wordcloud = WordCloud(width=800, height=400, background_color='white').generate(row['Cleaned_Sentences'])
    wordclouds[row['Presidents']] = wordcloud

plt.figure(figsize=(15, 10))
for i, (president, wordcloud) in enumerate(wordclouds.items(), 1):
    plt.subplot(2, 2, i)  
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.title(president)
    plt.axis("off")
plt.show()
```



```{python}
#| echo: false

data['Processed_Sentences'] = data['Sentences'].str.lower().str.replace('[^\w\s]', '', regex=True)

text_data = data['Processed_Sentences']
y = data['Presidents']

vectorizer = CountVectorizer(lowercase=True, token_pattern=r"(?u)\b\w+\b", stop_words='english')

X = vectorizer.fit_transform(text_data)

# Encode the class labels
le = LabelEncoder()
y_encoded = le.fit_transform(y)

# Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded)

```


## Model Evaluation
### Accuracy

From the accuracy table (Table 1), it's evident that the feature extraction method plays a pivotal role in the performance of models when classifying the origin of SONA presidential sentences. When employing the Bag of Words technique, the Support Vector Machines (SVM) model yields the highest accuracy at 59.354%, closely followed by Neural Networks with 58.797% and Boosted Trees (Catboost) at 56.182%. The TF-IDF method sees a similar trend, with SVM leading at 61.471%, Neural Networks registering 59.581%, and Boosted Trees (Catboost) trailing slightly at 55.569%. It's noteworthy that SVM attains its peak accuracy with the TF-IDF extraction method. However, all three models exhibit a sharp decline in performance when using Word Embeddings, with accuracies plummeting to below 34%. This indicates that, for this particular task, traditional methods like Bag of Words and TF-IDF outperform Word Embeddings. It should be noted that the word embeddings feature extraction despite setting a random state, varied in its performance across different runs, though across all runs still performed the worst of all feature extraction methods investigated in terms of accuracy.
```{python}
#| echo: false
#| fig-cap: "Table 1: Accuracy across models and feature extraction methods"
import plotly.graph_objects as go

# Creating the DataFrame
data_tab1 = {
    'Models/Feature Extraction': ['Boosted Trees(Catboost)', 'Support Vector Machines', 'Neural Networks'],
    'Bag of Words': [56.182, 59.354, 58.797],
    'TF-IDF': [55.569, 61.471, 59.581],
    'Word Embeddings': [28.902, 29.291, 33.852]
}

df_tab1 = pd.DataFrame(data_tab1)

model_column_style = dict(
    values=df_tab1['Models/Feature Extraction'],
    font=dict(color='black', size=12, family="Arial, sans-serif"),
    align='left'
)

fig = go.Figure(data=[go.Table(
    columnwidth=[200, 100, 100, 150], # Adjusting column width
    header=dict(values=list(df_tab1.columns),
                fill_color='lightgrey',
                line=dict(color='darkslategray', width=1),
                font=dict(color='black', size=12, family="Arial, sans-serif"),
                align='left',
                height=30),  # Adjusting header cell height
    cells=dict(
        values=[model_column_style['values']] + [df_tab1[col] for col in df_tab1.columns if col != 'Models/Feature Extraction'],
        fill=dict(color=['lightgrey', 'white', 'white', 'white']),
        line=dict(color='darkslategray', width=1),
        font=dict(color='black', size=11, family="Arial, sans-serif"),
        align='left',
        height=30)  # Adjusting cell height
)])

fig.update_layout(
    height = len(df_tab1) * 30 + 60,
    margin=dict(t=10, b=0, l=10, r=10)
)

fig.show()
```

### F1 Score

The F1-Score table (Table 2) provides insights into the harmonic mean between precision and recall for different models and feature extraction techniques. Using the Bag of Words method, Neural Networks achieve the highest F1-Score at 58.113%, slightly ahead of Support Vector Machines (SVM) which scored 57.850%. The Boosted Trees (Catboost) model lags a bit behind with a score of 53.552%. When the TF-IDF extraction technique is applied, SVM emerges as the top performer with a score of 60.121%. This is followed closely by the Neural Networks model with an F1-Score of 59.113%. Again, Boosted Trees (Catboost) secures the third position, achieving an F1-Score of 53.294%. However, when Word Embeddings are used for feature extraction, there is a notable drop in performance across all models. The Neural Networks model fares the best in this category with an F1-Score of 26.420%, while both SVM and Boosted Trees (Catboost) register scores below 15%. The stark contrast in performance when using Word Embeddings, compared to the other two methods, underscores its limitation for this specific task.

```{python}
#| echo: false
#| fig-cap: "Table 2: F1-Score across models and feature extraction methods"
import plotly.graph_objects as go

# Creating the DataFrame
data_tab1 = {
    'Models/Feature Extraction': ['Boosted Trees(Catboost)', 'Support Vector Machines', 'Neural Networks'],
    'Bag of Words': [53.552, 57.850, 58.113],
    'TF-IDF': [53.294, 60.121, 59.113],
    'Word Embeddings': [14.470, 13.271, 26.420]
}

df_tab1 = pd.DataFrame(data_tab1)

# Styling for the model names similar to header but bold
model_column_style = dict(
    values=df_tab1['Models/Feature Extraction'],
    font=dict(color='black', size=12, family="Arial, sans-serif"),
    align='left'
)

fig = go.Figure(data=[go.Table(
    columnwidth=[200, 100, 100, 150], # Adjusting column width
    header=dict(values=list(df_tab1.columns),
                fill_color='lightgrey',
                line=dict(color='darkslategray', width=1),
                font=dict(color='black', size=12, family="Arial, sans-serif"),
                align='left',
                height=30),  # Adjusting header cell height
    cells=dict(
        values=[model_column_style['values']] + [df_tab1[col] for col in df_tab1.columns if col != 'Models/Feature Extraction'],
        fill=dict(color=['lightgrey', 'white', 'white', 'white']),
        line=dict(color='darkslategray', width=1),
        font=dict(color='black', size=11, family="Arial, sans-serif"),
        align='left',
        height=30)  # Adjusting cell height
)])

fig.update_layout(
    height = len(df_tab1) * 30 + 60,
    margin=dict(t=10, b=0, l=10, r=10)
)

fig.show()
```


## Bag of Words
### Boosted Trees

Figure 5 shows the mean loss over each 5-fold cross-validation over 300 epochs over the boosted tree. Both losses exhibit a downward trend, signifying improvement in model performance with successive iterations. The training loss demonstrates a consistent decrease, reflecting the model's enhanced fitting to the training data. Concurrently, the validation loss also descends, suggesting improved model generalization to unseen data. Notably, the training loss decreases at a slightly accelerated rate compared to the validation loss. This observed trend warrants careful monitoring to prevent potential overfitting, ensuring the model maintains its predictive accuracy on external datasets.

```{python}
#| echo: false
#| eval: false
pool = Pool(data=X_train, label=y_train, cat_features=[])
# Parameters for the CatBoostClassifier
params = {
    'iterations': 3000,          # Number of boosting iterations
    'depth': 5,                # Depth of the trees
    'learning_rate': 0.05,      # Learning rate
    'loss_function': 'MultiClass',  # Objective function
    'random_seed': 42,             # Random seed
    'verbose': 10                   # Output training information every 10 iterations
}

cv_results = cv(
    pool=pool,
    params=params,
    fold_count=5,  # Number of folds in CV
    plot=False,   
    early_stopping_rounds=10
)

# Save cross-validation results to a CSV file
cv_results.to_csv('cv_results_over_epochs.csv', index=False)

 Train the model on the full training set and save it
clf = CatBoostClassifier(**params)
clf.fit(pool)
clf.save_model('catboost_BOW.cbm')


```

```{python}
#| echo: false
loaded_model = CatBoostClassifier()
loaded_model.load_model('catboost_BOW.cbm')

# Make predictions on the testing data
y_pred = loaded_model.predict(X_test)
y_pred_decoded = le.inverse_transform(y_pred.flatten().astype(int))

# Evaluate the classifier
accuracy = accuracy_score(y_test, y_pred.flatten().astype(int))
classification_rep = classification_report(y_test, y_pred.flatten().astype(int), target_names=le.classes_)
```

```{python}
#| echo: false
#| fig-cap: "Figure 5: Bag of Words Catboost Training and Validation Error Over Epochs"
# Read the CSV file
new_df = pd.read_csv("cv_results_over_epochs.csv")

plt.plot(new_df['iterations'], new_df['train-MultiClass-mean'], label='Training Error', color='b')  # 'b' stands for blue
plt.plot(new_df['iterations'], new_df['test-MultiClass-mean'], label='Validation Error', color='r')  # 'r' stands for red

plt.title('Training and Validation Error Over Epochs')
plt.xlabel('Epochs (Iterations)')
plt.ylabel('Error')

plt.legend()
plt.show()
```


Figure 6 shows the Boosted Tree's performance for the categories: Mandela, Mbeki, Ramaphosa, and Zuma. For correct classifications: 93 for Mandela, 278 for Mbeki, 253 for Ramaphosa, and 385 for Zuma, indicating varying degrees of accuracy across classes. Notably, the Boosted Tree's is most accurate when predicting Zuma and least accurate for Mandela. 
```{python}
#| echo: false
#| fig-cap: "Figure 6 Bag of Words Catboost Confusion Matrix"
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix

# confusion matrix
cm = confusion_matrix(y_test, y_pred.flatten().astype(int))
classes = le.classes_

plt.figure(figsize=(10,7))
sns.set(font_scale=1.4) 
sns.heatmap(cm, annot=True, annot_kws={"size": 16}, fmt='g', cmap='Blues', xticklabels=classes, yticklabels=classes)

plt.xlabel('Predicted label')
plt.ylabel('True label')
plt.title('Confusion Matrix')
plt.show()
```


```{python}
#| echo: false
import matplotlib.pyplot as plt
import seaborn as sns
```


### Neural Network

 Figure 7 Shows the mean training and validation accuracy across 20 epochs using 5-fold cross-validation on the training dataset. We observe little evidence of significant learning in the validation set over the epochs, with the validation accuracy remaining constant over the 20 epochs. Hence given this the final model selected was chosen to run on 2 epochs. A possible reason for this could be the choice of the kernel weight initializer which provides a non-naive initial set of weights for the NN.

```{python}
#| echo: false
import numpy as np
from sklearn.model_selection import StratifiedKFold
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense
from tensorflow.keras.regularizers import l2
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

# Convert the sparse matrix to dense matrix 
X_train_dense = X_train.toarray()
X_test_dense = X_test.toarray()
seed = 7
np.random.seed(seed)
```

```{python}
#| eval: false
#| echo: false

num_folds = 5
kfold = StratifiedKFold(n_splits=num_folds, shuffle=True, random_state=seed)

# Initialize variables to store sum of accuracies for each epoch
sum_train_accuracy = []
sum_val_accuracy = []

for train, test in kfold.split(X_train_dense, y_train):
    Split data into train and validation sets for this fold
    X_train_fold, X_val_fold = X_train_dense[train], X_train_dense[test]
    y_train_fold, y_val_fold = y_train[train], y_train[test]

    # Define model
    model = Sequential([
        Dense(505, input_dim=X_train_fold.shape[1], activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-8)),
        Dense(220, activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-7)),
        Dense(len(np.unique(y_train)), activation='softmax')
    ])
    
    # Compile model 
    model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

    # Train model and store training history
    history = model.fit(X_train_fold, y_train_fold, validation_data=(X_val_fold, y_val_fold), epochs=20)

    # Append accuracies
    sum_train_accuracy.append(history.history['accuracy'])
    sum_val_accuracy.append(history.history['val_accuracy'])

# Compute average 
avg_train_accuracy = np.mean(sum_train_accuracy, axis=0)
avg_val_accuracy = np.mean(sum_val_accuracy, axis=0)

# Save averaged accuracies to CSV
avg_accuracies_df = pd.DataFrame({'avg_train_accuracy': avg_train_accuracy, 'avg_val_accuracy': avg_val_accuracy})
avg_accuracies_df.to_csv('avg_accuracies_over_epochs_NN_1.csv', index=False)
```
```{python}
#| echo: false
#| fig-cap: "Figure: 7 Bag of Words Neural Network Average Training and Validation Accuracy Over Epochs"
loaded_avg_accuracies = pd.read_csv('avg_accuracies_over_epochs_NN_1.csv')

# Plotting
plt.figure(figsize=(12, 6))
plt.plot(range(1, len(loaded_avg_accuracies['avg_train_accuracy']) + 1), loaded_avg_accuracies['avg_train_accuracy'], label='Average Training Accuracy')
plt.plot(range(1, len(loaded_avg_accuracies['avg_val_accuracy']) + 1), loaded_avg_accuracies['avg_val_accuracy'], label='Average Validation Accuracy', linestyle='dashed')

plt.title('Average Training and Validation Accuracy Over Epochs')
plt.xlabel('Epoch')
plt.xticks(range(1, len(loaded_avg_accuracies['avg_train_accuracy']) + 1)) 
plt.ylabel('Accuracy')
plt.legend(loc='upper left')
plt.show()
```




```{python}
#| echo: false
X_train = X_train.toarray()
X_test = X_test.toarray()
```

```{python}
#| echo: false
#| eval: false

 Define model
model = Sequential([
    Dense(505, input_dim=X_train.shape[1], activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-8)),  # Input layer
    Dense(220, activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-7)),  # Hidden layer
    Dense(len(label_mapping), activation='softmax')  # Output layer
])

# Compile model
model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])


epochs = 2
model.fit(X_train, y_train, validation_split=0.2, epochs=epochs)

# Save the final model
model.save('NN_final_model_1.h5')

```

```{python}
#| echo: false
loaded_model = load_model('NN_final_model_1.h5')


# Evaluate the loaded model on the test set
final_loss, final_accuracy = loaded_model.evaluate(X_test, y_test, verbose = 0)
```

In Figure 8 Neural Network classifier exhibits varying degrees of classification accuracy across different classes. For Mandela, out of 334 instances, 170 were correctly classified, with an accuracy of 50.9%. The Mbeki class had 264 (55.0%) a. The classifier achieved higher accuracy for Ramaphosa, correctly classifying 291 (63.8%). The highest accuracy was observed for the Zuma class, with 331 (62.9%).

With respect to the misclassifications: Mandela was often misclassified as Mbeki (92 instances) or Zuma (45 instances). Mbeki instances were misclassified as Mandela (91 instances) and Zuma (76 instances). There were 97 Ramaphosa instances misclassified as Zuma. For the Zuma class, there were 88, 52, and 55 instances misclassified as Ramaphosa, Mandela, and Mbeki respectively. 

```{python}
#| include: false
y_pred = loaded_model.predict(X_test)
y_pred_classes = np.argmax(y_pred, axis=1) 
```

```{python}
#| echo: false
#| fig-cap: "Figure 8: Bag of Words Neural Network Confusion Matrix "
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay



# Compute the confusion matrix
cm = confusion_matrix(y_test, y_pred_classes)
plt.figure(figsize=(10, 7))
sns.set(font_scale=1.2)  # for label size
sns.heatmap(cm, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12},xticklabels=classes, yticklabels=classes)  # font size

plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()
```


### SVMs

```{python, eval = FALSE}
#| echo: false
#| eval: false
param_grid = {
    'C': [0.1, 1, 10],  # Regularization parameter
    'kernel': ['linear', 'rbf'],  # Type of SVM
    'gamma': ['scale', 'auto']  # Kernel coefficient
}

# Initialize the SVM classifier
svm = SVC(random_state=42)

# Initialize Grid Search
grid_search = GridSearchCV(estimator=svm, param_grid=param_grid, cv=3, scoring='accuracy')

# Perform Grid Search on the training data
grid_search.fit(X_train, y_train)

best_params = grid_search.best_params_
best_svm_clf = grid_search.best_estimator_

# Make predictions using the best model
y_pred_best_svm = best_svm_clf.predict(X_test)

# Evaluate the best model
accuracy_best_svm = accuracy_score(y_test, y_pred_best_svm)
classification_rep_best_svm = classification_report(y_test, y_pred_best_svm)

```


```{python}
#| echo: false
# Initialize the Support Vector Machine classifier
svm_clf = SVC(kernel='linear', gamma = 'scale', C = 0.1, random_state=42)
```
```{python}
#| echo: false
#| eval: false
# Fit the model on the training data
 svm_clf.fit(X_train, y_train)


# Using pickle
with open('svm_model1.pkl', 'wb') as model_file:
    pickle.dump(svm_clf, model_file)
```
```{python}
#| echo: false
# Using pickle
with open('svm_model1.pkl', 'rb') as model_file:
    loaded_svm_pickle1 = pickle.load(model_file)

y_pred_svm = loaded_svm_pickle1.predict(X_test)

# Evaluate the classifier
accuracy_svm = accuracy_score(y_test, y_pred_svm)
classification_rep_svm = classification_report(y_test, y_pred_svm)

```

Figure 9 shows for the Mandela class, there were 139(41.6%). The Mbeki class had an accuracy of 54.8%. The classifier was more accurate in identifying Ramaphosa, correctly classifying 271 (59.4%). The highest classification accuracy was observed for the Zuma class, with 393 correct, achieving 74.7% accuracy.

Patterns of misclassification were also observed across the classes. For instance, Mandela was often misclassified as Mbeki (80 instances) and Zuma (77 instances). Instances of Mbeki were misclassified as Mandela (71 instances) and Zuma (99 instances). Notably, Ramaphosa was misclassified as Zuma in 126 instances.
```{python}
#| echo: false
#| fig-cap: "Figure 9: Bag of Words SVM Confusion Matrix"
# Compute the confusion matrix
cm_svm = confusion_matrix(y_test, y_pred_svm)

# Visualize the confusion matrix
fig_svm, ax_svm = plt.subplots(figsize=(10, 7))
sns.set(font_scale=1.2)  # for label size
sns.heatmap(cm_svm, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12}, ax=ax_svm,xticklabels=classes, yticklabels=classes)  

ax_svm.set_title('SVM Confusion Matrix')
ax_svm.set_xlabel('Predicted Label')
ax_svm.set_ylabel('True Label')
plt.show()

```




## TF-IDF


```{python}
#| echo: false

vectorizer = TfidfVectorizer(stop_words='english')

X = vectorizer.fit_transform(data['Sentences'])

y = data['Presidents']

# Split the data into training and testing sets with an 80-20 ratio
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

```


### Boosted Trees


```{python}
#| echo: false
# Initialize LabelEncoder
le = LabelEncoder()

# Fit and transform the training data
y_train_encoded = le.fit_transform(y_train)

# Transform the testing data
y_test_encoded = le.transform(y_test)

# Create pool with training data
pool = Pool(data=X_train, label=y_train_encoded, cat_features=[])

# Parameters for CatBoostClassifier
params = {
    'iterations': 3000,
    'depth': 5,
    'learning_rate': 0.05,
    'loss_function': 'MultiClass',
    'random_seed': 42,
    'verbose': 10
}
```
```{python}
#| echo: false
#| eval: false

# Perform cross-validation and save results
cv_results = cv(
    pool=pool,
    params=params,
    fold_count=5,
    plot=False,
    early_stopping_rounds=10
)

 Save cross-validation results to a CSV file
cv_results.to_csv('cv_results_over_epochs_2.csv', index=False)

 Train model on full training set and save it
clf = CatBoostClassifier(**params)
clf.fit(pool)
clf.save_model('catboost_TFIDF.cbm')
```

```{python}
#| echo: false
# Load model from file
loaded_model = CatBoostClassifier()
loaded_model.load_model('catboost_TFIDF.cbm')

# Make predictions on testing data
y_pred = loaded_model.predict(X_test)
y_pred_class = y_pred.flatten().astype(int)

# Inverse transform the predictions back to original labels
y_pred_decoded = le.inverse_transform(y_pred_class)

accuracy = accuracy_score(y_test_encoded, y_pred_class)
classification_rep = classification_report(y_test_encoded, y_pred_class, target_names=le.classes_)

```


The results of the training over epochs for the GBT model using TF-IDF can be seen in the appendix(Figure A1), though are largely the same in behaviour as the GBT model trained using the BoW feature extraction. Hence the final model chosen has the same hyperparameters. The confusion matrix for the Gradient Boosting Trees (GBT) classifier (Figure 10) reveals a classification accuracy of 28.7% for Mandela, with 96 correct predictions. The Mbeki class demonstrated a higher accuracy of 59.2% with 284 correct predictions from 480 instances. The Ramaphosa class was accurately identified in 261 out of 456 instances, yielding an accuracy of 57.2%. The Zuma class exhibited the highest classification accuracy at 68.3%, with 359 correct predictions from 526 instances. In terms of misclassifications, these appear less pronounced but we do see, that Mandela was often confused with Mbeki (113 instances).


```{python}
#| echo: false
#| fig-cap: "Figure 10: TF-IDF Catboost Confusion Matrix"
cm_catboost = confusion_matrix(y_test_encoded, y_pred_class)

# Visualize the confusion matrix
fig_catboost, ax_catboost = plt.subplots(figsize=(10, 7))
sns.set(font_scale=1.2)  # for label size
sns.heatmap(cm_catboost, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12}, ax=ax_catboost,xticklabels=classes, yticklabels=classes)  

ax_catboost.set_title('CatBoost Confusion Matrix')
ax_catboost.set_xlabel('Predicted Label')
ax_catboost.set_ylabel('True Label')
plt.show()
```

### SVM


```{python}
#| echo: false
#| eval: false
param_grid = {
    'C': [0.1, 1, 10],  # Regularization parameter
    'kernel': ['linear', 'rbf'],  # Type of SVM
    'gamma': ['scale', 'auto']  # Kernel coefficient
}

# Initialize the SVM classifier
svm = SVC(random_state=42)

# Initialize Grid Search
grid_search = GridSearchCV(estimator=svm, param_grid=param_grid, cv=3, scoring='accuracy')

grid_search.fit(X_train, y_train)

# Get the best parameters and the best estimator from Grid Search
best_params = grid_search.best_params_
best_svm_clf = grid_search.best_estimator_

y_pred_best_svm = best_svm_clf.predict(X_test)

# Evaluate the best model
accuracy_best_svm = accuracy_score(y_test, y_pred_best_svm)
classification_rep_best_svm = classification_report(y_test, y_pred_best_svm)

```

```{python}
#| echo: false
# Initialize the Support Vector Machine classifier
svm_clf = SVC(kernel='rbf', gamma = 'scale', C = 10, random_state=42)

# Fit the model on the training data
svm_clf.fit(X_train, y_train)

with open('svm_model2.pkl', 'wb') as model_file:
    pickle.dump(svm_clf, model_file)
```

```{python}
#| echo: false
# Using pickle
with open('svm_model2.pkl', 'rb') as model_file:
    loaded_svm2_pickle = pickle.load(model_file)

# Make predictions on the testing data
y_pred_svm = loaded_svm2_pickle.predict(X_test)

# Evaluate the classifier
accuracy_svm = accuracy_score(y_test, y_pred_svm)
classification_rep_svm = classification_report(y_test, y_pred_svm)

```

```{python}
#| echo: false
#| fig-cap: "Figure 11: TF-IDF SVM Confusion Matrix"
# Compute the confusion matrix
cm_svm2 = confusion_matrix(y_test, y_pred_svm)

# Visualize the confusion matrix
fig_svm2, ax_svm2 = plt.subplots(figsize=(10, 7))
sns.set(font_scale=1.2)  # for label size
sns.heatmap(cm_svm2, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12}, ax=ax_svm2,xticklabels=classes, yticklabels=classes)  # font size

ax_svm2.set_title('SVM2 Confusion Matrix')
ax_svm2.set_xlabel('Predicted Label')
ax_svm2.set_ylabel('True Label')
plt.show()
```


Looking to Figure 11 for the SVM classifier using TF- IDF feature extraction the confusion matrix denotes: Mandela at 42.8%, with 143; Mbeki at 61.9%, with 297 correct predictions; Ramaphosa at 64.3%, with 293 correct predictions; and Zuma at 70.5%, with 371 correct predictions.

In terms of notable misclassifications, the classifier misidentified Ramaphosa 109 times as Zuma. 


### Neural Net

```{python}
#| echo: false
import numpy as np
from sklearn.model_selection import StratifiedKFold
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense
from tensorflow.keras.regularizers import l2
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

X_train_dense = X_train.toarray()
X_test_dense = X_test.toarray()

encoder = LabelEncoder()
y_train = encoder.fit_transform(y_train)
```


```{python}
#| echo: false
#| eval: false
seed = 7
np.random.seed(seed)

# Define 5-fold cross-validation
num_folds = 5
kfold = StratifiedKFold(n_splits=num_folds, shuffle=True, random_state=seed)

# Initialize variables to store sum of accuracies for each epoch
sum_train_accuracy = []
sum_val_accuracy = []

for train, test in kfold.split(X_train_dense, y_train):
     Split data into train and validation sets for this fold
    X_train_fold, X_val_fold = X_train_dense[train], X_train_dense[test]
    y_train_fold, y_val_fold = y_train[train], y_train[test]

    model = Sequential([
        Dense(505, input_dim=X_train_fold.shape[1], activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-8)),
        Dense(220, activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-7)),
        Dense(len(np.unique(y_train)), activation='softmax')
    ])
    
    model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

    # Train model and store training history
    history = model.fit(X_train_fold, y_train_fold, validation_data=(X_val_fold, y_val_fold), epochs=20)

    # Append accuracies for each epoch for this fold
    sum_train_accuracy.append(history.history['accuracy'])
    sum_val_accuracy.append(history.history['val_accuracy'])

# Compute average accuracies for each epoch
avg_train_accuracy = np.mean(sum_train_accuracy, axis=0)
avg_val_accuracy = np.mean(sum_val_accuracy, axis=0)

# Save averaged accuracies to CSV
avg_accuracies_df = pd.DataFrame({'avg_train_accuracy': avg_train_accuracy, 'avg_val_accuracy': avg_val_accuracy})
avg_accuracies_df.to_csv('avg_accuracies_over_epochs_NN_2.csv', index=False)


```

```{python}
#| echo: false
#X_train = X_train.toarray()
#X_test = X_test.toarray()
encoder = LabelEncoder()
y_test = encoder.fit_transform(y_test)
```
```{python}
#| echo: false
#| eval: false
# Define model
model = Sequential([
    Dense(505, input_dim=X_train.shape[1], activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-8)),  # Input layer
    Dense(220, activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-7)),  # Hidden layer
    Dense(len(label_mapping), activation='softmax')  # Output layer
])

# Compile model
model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])


epochs = 2
model.fit(X_train, y_train, validation_split=0.2, epochs=epochs)

# Save the final model
model.save('NN_final_model_2.h5')

```

```{python}
#| echo: false
# Load the final model
loaded_model = load_model('NN_final_model_2.h5')


# Evaluate the loaded model on the test set
final_loss, final_accuracy = loaded_model.evaluate(X_test, y_test, verbose = 0)

```

Figure 12 illustrates the confusion matrix for the NN trained using TF-IDF feature extraction. For Mandela, the NN secured 182 correct predictions (54.5%). The Mbeki class observed an accuracy of 60.6% with 291 correct predictions. For Ramaphosa, 276 correct predictions were made (60.5%). The highest accuracy was noted for the Zuma class, with 321 with an accuracy of 61.0%.

In terms of misclassifications, we note similar patterns in misclassifications between Zuma and Ramaphosa. 

```{python}
#| include: false
y_pred_nn2 = loaded_model.predict(X_test)
y_pred_nn2_classes = np.argmax(y_pred_nn2, axis=1) 
```

```{python}
#| echo: false
#| fig-cap: "Figure 12: TF-IDF Neural Network Confusion Matrix"
 # Convert probabilities to class labels

# Compute the confusion matrix
# Note: Ensure that y_test is the encoded version of the true labels
cm_nn2 = confusion_matrix(y_test, y_pred_nn2_classes)

# Visualize the confusion matrix
fig_nn2, ax_nn2 = plt.subplots(figsize=(10, 7))
sns.set(font_scale=1.2)  # for label size
sns.heatmap(cm_nn2, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12}, ax=ax_nn2,xticklabels=classes, yticklabels=classes )  # font size

ax_nn2.set_title('NN2 Confusion Matrix')
ax_nn2.set_xlabel('Predicted Label')
ax_nn2.set_ylabel('True Label')
plt.show()
```




## Word Embeddings 


```{python}
#| echo: false
# Tokenize sentences using white-space-based tokenization
data['Tokenized_Sentences'] = data['Sentences'].apply(lambda x: x.split())

# Train Word2Vec model
word2vec_model = Word2Vec(sentences=data['Tokenized_Sentences'], vector_size=100, window=5, min_count=1, workers=4)

# Function to calculate sentence embedding
def sentence_embedding(sentence_tokens, model):
    """Calculate sentence embedding as the mean of the word embeddings."""
    embeddings = [model.wv[word] for word in sentence_tokens if word in model.wv.index_to_key]
    return np.mean(embeddings, axis=0) if len(embeddings) > 0 else np.zeros(model.vector_size)

# Create sentence embeddings
data['Sentence_Embeddings'] = data['Tokenized_Sentences'].apply(lambda x: sentence_embedding(x, word2vec_model))

# Encode the "Presidents" labels into numerical format
label_mapping = {label: idx for idx, label in enumerate(data['Presidents'].unique())}
data['Label'] = data['Presidents'].map(label_mapping)

X = np.vstack(data['Sentence_Embeddings'].to_numpy())
y = data['Label'].to_numpy()

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

```


### Catboost
```{python}
#| echo: false
#| include: false
pool = Pool(data=X_train, label=y_train, cat_features=[])
# Parameters for the CatBoostClassifier
params = {
    'iterations': 3000,          # Number of boosting iterations
    'depth': 5,                # Depth of the trees
    'learning_rate': 0.05,      # Learning rate
    'loss_function': 'MultiClass',  # Objective function
    'random_seed': 42,             # Random seed
    'verbose': 10                   # Output training information every 10 iterations
}
```
```{python}
#| echo: false
#| eval: false
cv_results = cv(
    pool=pool,
    params=params,
    fold_count=5,  # Number of folds in CV
    plot=False,   # Set to True if you want to see the plot of train and test errors during cross-validation
    early_stopping_rounds=10
)

# Save cross-validation results to a CSV file
cv_results.to_csv('cv_results_over_epochs_3.csv', index=False)

# Train the model on the full training set and save it
clf = CatBoostClassifier(**params)
clf.fit(pool)
clf.save_model('catboost_WordEmbed.cbm')
```


```{python}
#| include: false
# Load the model from the file
loaded_model = CatBoostClassifier()
loaded_model.load_model('catboost_WordEmbed.cbm')

# Make predictions on the testing data
y_pred = loaded_model.predict(X_test)
y_pred_decoded = le.inverse_transform(y_pred.flatten().astype(int))

# Evaluate the classifier
accuracy = accuracy_score(y_test, y_pred.flatten().astype(int))
classification_rep = classification_report(y_test, y_pred.flatten().astype(int), target_names=le.classes_)
```



```{python}
#| echo: false
#| eval: false
cm_catboost2 = confusion_matrix(y_test, y_pred.flatten().astype(int))

fig_catboost2, ax_catboost2 = plt.subplots(figsize=(10, 7))
sns.set(font_scale=1.2)  # for label size
sns.heatmap(cm_catboost2, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12}, ax=ax_catboost2,xticklabels=classes, yticklabels=classes)  # font size

ax_catboost2.set_title('CatBoost2 Confusion Matrix')
ax_catboost2.set_xlabel('Predicted Label')
ax_catboost2.set_ylabel('True Label')
#fig_catboost2.savefig('GBTWE.png', dpi=400,bbox_inches='tight')
```



Figure 13 shows confusion matrix of the GBT using word embeddings. For the Mandela class, out of 334 instances, there were no correct predictions, resulting in a classification accuracy of 0%. The Mbeki class similarly did not have any correct predictions, but 3 instances were misclassified as Mandela. The Ramaphosa class achieved the highest accuracy, with 505 correct predictions, translating to an accuracy of 96%. The Zuma class had 14 correct predictions, yielding an accuracy of 3.1%.

The significant misclassifications into the Ramaphosa class from other categories suggest a strong bias in the classifier towards this class, which is concerning yet somewhat unsurprising given the model's performance in terms of accuracy and F1-score.


```{python}
#| echo: false
#| fig-cap: "Figure 13: Word Embeddings Catboost Confusion Matrix"
import matplotlib.image as mpimg
# Load the saved image
img = mpimg.imread('GBTWE.png')
plt.imshow(img)
plt.axis('off')  
plt.show()
```

### SVM

```{python}
#| echo: false
#| eval: false
#| include: false
param_grid = {
    'C': [0.1, 1, 10],  # Regularization parameter
    'kernel': ['linear', 'rbf'],  # Type of SVM
    'gamma': ['scale', 'auto']  # Kernel coefficient
}

# Initialize the SVM classifier
svm = SVC(random_state=42)

# Initialize Grid Search
grid_search = GridSearchCV(estimator=svm, param_grid=param_grid, cv=3, scoring='accuracy')

# Perform Grid Search on the training data
grid_search.fit(X_train, y_train)

# Get the best parameters and the best estimator from Grid Search
best_params = grid_search.best_params_
best_svm_clf = grid_search.best_estimator_

# Make predictions using the best model
y_pred_best_svm = best_svm_clf.predict(X_test)

# Evaluate the best model
accuracy_best_svm = accuracy_score(y_test, y_pred_best_svm)
classification_rep_best_svm = classification_report(y_test, y_pred_best_svm, target_names=label_mapping.keys())
```


```{python}
#| echo: false
#| include: false
#| eval: false
# Initialize the Support Vector Machine classifier with specific parameters
specific_svm_clf = SVC(kernel='linear', gamma='scale', C=10, random_state=42)

# Fit the model on the training data
specific_svm_clf.fit(X_train, y_train)

with open('svm_model3.pkl', 'wb') as model_file:
    pickle.dump(specific_svm_clf, model_file)
```


```{python}
#| echo: false
#| include: false
with open('svm_model3.pkl', 'rb') as model_file:
    loaded_svm3_pickle = pickle.load(model_file)

# Make predictions on the testing data
y_pred_specific_svm = loaded_svm3_pickle.predict(X_test)



# Evaluate the classifier
accuracy_specific_svm = accuracy_score(y_test, y_pred_specific_svm)
classification_rep_specific_svm = classification_report(y_test, y_pred_specific_svm, target_names=label_mapping.keys())

```


In Figure 14 we see the word embeddings SVM confusion matrix: The model upon investigation here has failed greatly. It has simply predicted all sentences belonging to Ramaphosa and hence cannot be interpreted at any meaningful level.
```{python}
#| echo: false
#| eval: false
cm_specific_svm = confusion_matrix(y_test, y_pred_specific_svm)


fig_specific_svm, ax_specific_svm = plt.subplots(figsize=(10, 7))
sns.set(font_scale=1.2)  
sns.heatmap(cm_specific_svm, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12}, ax=ax_specific_svm,xticklabels=classes, yticklabels=classes)  
ax_specific_svm.set_title('Specific SVM Confusion Matrix')
ax_specific_svm.set_xlabel('Predicted Label')
ax_specific_svm.set_ylabel('True Label')
#fig_specific_svm.savefig('SVMWE.png', dpi=400,bbox_inches='tight')

```

```{python}
#| echo: false
#| fig-cap: "Figure 14: Word Embeddings SVM Confusion Matrix "
import matplotlib.image as mpimg

img = mpimg.imread('SVMWE.png')

plt.imshow(img)
plt.axis('off') 
plt.show()
```

### Neural Network 

```{python}
#| echo: false
import numpy as np
from sklearn.model_selection import StratifiedKFold
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Dense
from tensorflow.keras.regularizers import l2
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

# Convert the sparse matrix to dense matrix as neural network needs dense input
#X_train_dense = X_train.toarray()
#X_test_dense = X_test.toarray()

encoder = LabelEncoder()
y_train = encoder.fit_transform(y_train)
```

```{python}
#| eval: false
#| echo: false
seed = 7
np.random.seed(seed)

# Define 5-fold cross-validation
num_folds = 5
kfold = StratifiedKFold(n_splits=num_folds, shuffle=True, random_state=seed)

 Initialize variables to store sum of accuracies for each epoch
sum_train_accuracy = []
sum_val_accuracy = []

for train, test in kfold.split(X_train_dense, y_train):
    Split data into train and validation sets for this fold
    X_train_fold, X_val_fold = X_train_dense[train], X_train_dense[test]
    y_train_fold, y_val_fold = y_train[train], y_train[test]

    model = Sequential([
        Dense(505, input_dim=X_train_fold.shape[1], activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-8)),
        Dense(220, activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-7)),
        Dense(len(np.unique(y_train)), activation='softmax')
    ])
    
    model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

     Train model and store training history
    history = model.fit(X_train_fold, y_train_fold, validation_data=(X_val_fold, y_val_fold), epochs=20)

     Append accuracies for each epoch for this fold
    sum_train_accuracy.append(history.history['accuracy'])
    sum_val_accuracy.append(history.history['val_accuracy'])

# Compute average accuracies for each epoch
avg_train_accuracy = np.mean(sum_train_accuracy, axis=0)
avg_val_accuracy = np.mean(sum_val_accuracy, axis=0)

 Save averaged accuracies to CSV
avg_accuracies_df = pd.DataFrame({'avg_train_accuracy': avg_train_accuracy, 'avg_val_accuracy': avg_val_accuracy})
avg_accuracies_df.to_csv('avg_accuracies_over_epochs_NN_3.csv', index=False)


```

```{python}
#| echo: false
#X_train = X_train.toarray()
#X_test = X_test.toarray()
encoder = LabelEncoder()
y_test = encoder.fit_transform(y_test)
```
```{python}
#| eval: false
#| echo: false

 Define model
model = Sequential([
    Dense(505, input_dim=X_train.shape[1], activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-8)),  # Input layer
    Dense(220, activation='relu', kernel_initializer='he_normal', kernel_regularizer=l2(1e-7)),  # Hidden layer
    Dense(len(label_mapping), activation='softmax')  # Output layer
])

# Compile model
model.compile(loss='sparse_categorical_crossentropy', optimizer='adam', metrics=['accuracy'])


epochs = 3
model.fit(X_train, y_train, validation_split=0.2, epochs=epochs)

# Save the final model
model.save('NN_final_model_3.h5')
```

```{python}
#| echo: false
# Load the final model
loaded_model = load_model('NN_final_model_3.h5')


# Evaluate the loaded model on the test set
final_loss, final_accuracy = loaded_model.evaluate(X_test, y_test, verbose = 0)

```


```{python}
#| echo: false
#| eval: false
y_pred_nn3 = loaded_model.predict(X_test)
y_pred_nn3_classes = np.argmax(y_pred_nn3, axis=1)  


cm_nn3 = confusion_matrix(y_test, y_pred_nn3_classes)

# Visualize the confusion matrix
fig_nn3, ax_nn3 = plt.subplots(figsize=(10, 7))
sns.set(font_scale=1.2)  # for label size
sns.heatmap(cm_nn3, annot=True, fmt='g', cmap='Blues', annot_kws={"size": 12}, ax=ax_nn3,xticklabels=classes, yticklabels=classes)  # font size

ax_nn3.set_title('NN3 Confusion Matrix')
ax_nn3.set_xlabel('Predicted Label')
ax_nn3.set_ylabel('True Label')
plt.show()

#fig_nn3.savefig("NNWE.png",dpi=400,bbox_inches='tight')
```

We finally examine the confusion matrix for the NN using word embeddings in Figure 15. The Neural Network classifier's performance varied across the classes. In Mandela's class, none were correctly predicted, with 235 instances being misclassified as Ramaphosa. The Mbeki class had a somewhat better accuracy of 28.3%, securing 136, but a notable 323 instances were erroneously labelled as Ramaphosa. The classifier's strongest performance was with the Ramaphosa class, achieving an accuracy of 81.9%, correctly predicting 431 instances. The Zuma class resulted in an accuracy of 9.0%, with 41 accurate predictions from 456 instances. However, a significant number, 347 instances, were mislabeled as Ramaphosa.

```{python}
#| echo: false
#| fig-cap: "Figure 15: Word Emdeddings Neural Network Confusion Matrix"
import matplotlib.image as mpimg
# Load the saved image
img = mpimg.imread('NNWE.png')
plt.imshow(img)
plt.axis('off')  
plt.show()
```

# Discussion

The findings of this study emphasize the pivotal role of feature extraction methods in classifying sentences from SONA speeches of various South African presidents. Of the three feature extraction methods, traditional methods (BoW and TF-IDF) consistently outperformed Word Embeddings across the predictive models used.

The superior performance of SVMs, especially when paired with TF-IDF features, is noteworthy. This could be attributed to SVM's inherent ability to efficiently handle high-dimensional data spaces and its adeptness at discerning intricate patterns from the SONA speeches. Such capability highlights SVM's robustness, especially when dealing with text data that may have nuances in vocabulary and structure.

An observation from the data exploration phase was the imbalance present in the dataset. Zuma's significant representation, contrasted with the sparse data associated with figures like de Klerk and Montlanthe, was an evident challenge. These imbalances can lead models to be biased towards overrepresented classes. This bias was manifested in the Gradient Boosted Trees model’s strong inclination towards the Ramaphosa class when utilizing Word Embeddings. Addressing this imbalance in future studies, perhaps through techniques such as oversampling or the generation of synthetic data, may yield more balanced and generalizable results.

The variations in average sentence lengths across different presidents also offered intriguing insights. For instance, Mbeki's inclination for longer sentences could suggest a more detailed or intricate discourse style. Such differences might be indicative of unique communication styles, rhetorical strategies, or focal points.

The consistent decline in performance across all models when utilizing Word Embeddings was a surprising outcome. One potential explanation could be that the embeddings, especially if pre-trained on generic corpora, may not be adept at capturing the linguistic nuances of SONA speeches. This underscores the importance of domain-specific training or fine-tuning when dealing with specialized datasets.

The results from the Neural Networks, while promising, did not significantly overshadow the simpler SVM model. Given the depth and potential of Neural Networks, it might be beneficial to explore more exhaustive hyperparameter tuning or even delve into more advanced architectures. Sequence models, such as Recurrent Neural Networks (RNNs), which have demonstrated prowess in capturing the sequential nature of linguistic data, might be particularly promising for future iterations of this study. The computational efficiency of the SVM especially when compared to NNs, GBTS, and transformer transfer learning models like BERT underscores the value and impressive performance of SVMs in NLP classification tasks. 

# Conclusions

In summary, while the study has successfully delineated the linguistic tendencies across various South African presidents, it has also highlighted challenges and potential avenues for refinement. The interplay of feature extraction methods, model selection, and data intricacies presents a complex landscape, emphasizing the multifaceted nature of political speech classification. Future research can build upon these findings, integrating more advanced models, addressing dataset imbalances, and potentially fusing insights from other academic disciplines like linguistics and political science for a holistic understanding. Though, this paper has succeeded in critically examining the landscape of NLP classification, providing a robust direction for work in political NLP classification and detailed analysis and evaluation of the methods available. 

# Bibliography

Akuma, S., Lubem, T. and Adom, I.T. (2022) ‘Comparing bag of words and TF-IDF with different models for hate speech detection from live tweets’, International Journal of Information Technology, 14(7), pp. 3629–3635. doi:10.1007/s41870-022-01096-4. 

Brownlee, J. (2021) Gradient boosting with Scikit-learn, XGBoost, LIGHTGBM, and CatBoost, MachineLearningMastery.com. Available at: https://machinelearningmastery.com/gradient-boosting-with-scikit-learn-xgboost-lightgbm-and-catboost/ (Accessed: 4 October 2023). 

Dogra, V. et al. (2022) ‘A complete process of text classification system using state-of-the-art NLP models’, Computational Intelligence and Neuroscience, 2022, pp. 1–26. doi:10.1155/2022/1883698. 

Friedman, J.H. (2001) ‘Greedy function approximation: A gradient boosting machine.’, The Annals of Statistics, 29(5). doi:10.1214/aos/1013203451. 

Goodfellow, I., Bengio, Y. and Courville, A., 2016. Deep learning. MIT press.

Glorot, X., Bordes, A. and Bengio, Y., 2011. Deep sparse rectifier neural networks. In Proceedings of the fourteenth international conference on artificial intelligence and statistics (pp. 315-323).

He, K., Zhang, X., Ren, S. and Sun, J., 2015. Delving deep into rectifiers: Surpassing human-level performance on ImageNet classification. In Proceedings of the IEEE international conference on computer vision (pp. 1026-1034).

Kotei, E. and Thirunavukarasu, R. (2023) ‘A systematic review of transformer-based pre-trained language models through self-supervised learning’, Information, 14(3), p. 187. doi:10.3390/info14030187. 

Khurana, D. et al. (2022) ‘Natural language processing: State of the art, current trends and challenges’, Multimedia Tools and Applications, 82(3), pp. 3713–3744. doi:10.1007/s11042-022-13428-4. 

Řehůřek, R. (2022) Gensim: Topic modelling for humans, Word2Vec Model - gensim. Available at: https://radimrehurek.com/gensim/auto_examples/tutorials/run_word2vec.html#:~:text=Word2Vec%20is%20a%20more%20recent,each%20other%20have%20differing%20meanings. (Accessed: 6 October 2023). 

Shmilovici, A. (2005) ‘Support Vector Machines’, Data Mining and Knowledge Discovery Handbook, pp. 257–276. doi:10.1007/0-387-25465-x_12. 

Sklearn (2023) Sklearn.svm.SVC, scikit. Available at: https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html (Accessed: 13 October 2023). 